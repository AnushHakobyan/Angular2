// Reflect.decorate ( decorators, target [, propertyKey [, descriptor] ] )
import "../../Reflect";
import * as assert from "assert";
export function ReflectDecorateThrowsIfDecoratorsArgumentNotArrayForFunctionOverload() {
    let target = function () { };
    assert.throws(() => Reflect.decorate(undefined, target, undefined, undefined), TypeError);
}
export function ReflectDecorateThrowsIfTargetArgumentNotFunctionForFunctionOverload() {
    let decorators = [];
    let target = {};
    assert.throws(() => Reflect.decorate(decorators, target, undefined, undefined), TypeError);
}
export function ReflectDecorateThrowsIfDecoratorsArgumentNotArrayForPropertyOverload() {
    let target = {};
    let name = "name";
    assert.throws(() => Reflect.decorate(undefined, target, name, undefined), TypeError);
}
export function ReflectDecorateThrowsIfTargetArgumentNotObjectForPropertyOverload() {
    let decorators = [];
    let target = 1;
    let name = "name";
    assert.throws(() => Reflect.decorate(decorators, target, name, undefined), TypeError);
}
export function ReflectDecorateThrowsIfDecoratorsArgumentNotArrayForPropertyDescriptorOverload() {
    let target = {};
    let name = "name";
    let descriptor = {};
    assert.throws(() => Reflect.decorate(undefined, target, name, descriptor), TypeError);
}
export function ReflectDecorateThrowsIfTargetArgumentNotObjectForPropertyDescriptorOverload() {
    let decorators = [];
    let target = 1;
    let name = "name";
    let descriptor = {};
    assert.throws(() => Reflect.decorate(decorators, target, name, descriptor), TypeError);
}
export function ReflectDecorateExecutesDecoratorsInReverseOrderForFunctionOverload() {
    let order = [];
    let decorators = [
            (target) => { order.push(0); },
            (target) => { order.push(1); }
    ];
    let target = function () { };
    Reflect.decorate(decorators, target);
    assert.deepEqual(order, [1, 0]);
}
export function ReflectDecorateExecutesDecoratorsInReverseOrderForPropertyOverload() {
    let order = [];
    let decorators = [
            (target, name) => { order.push(0); },
            (target, name) => { order.push(1); }
    ];
    let target = {};
    let name = "name";
    Reflect.decorate(decorators, target, name, undefined);
    assert.deepEqual(order, [1, 0]);
}
export function ReflectDecorateExecutesDecoratorsInReverseOrderForPropertyDescriptorOverload() {
    let order = [];
    let decorators = [
            (target, name) => { order.push(0); },
            (target, name) => { order.push(1); }
    ];
    let target = {};
    let name = "name";
    let descriptor = {};
    Reflect.decorate(decorators, target, name, descriptor);
    assert.deepEqual(order, [1, 0]);
}
export function ReflectDecoratorPipelineForFunctionOverload() {
    let A = function A() { };
    let B = function B() { };
    let decorators = [
            (target) => { return undefined; },
            (target) => { return A; },
            (target) => { return B; }
    ];
    let target = function () { };
    let result = Reflect.decorate(decorators, target);
    assert.strictEqual(result, A);
}
export function ReflectDecoratorPipelineForPropertyOverload() {
    let A = {};
    let B = {};
    let decorators = [
            (target, name) => { return undefined; },
            (target, name) => { return A; },
            (target, name) => { return B; }
    ];
    let target = {};
    let result = Reflect.decorate(decorators, target, "name", undefined);
    assert.strictEqual(result, undefined);
}
export function ReflectDecoratorPipelineForPropertyDescriptorOverload() {
    let A = {};
    let B = {};
    let C = {};
    let decorators = [
            (target, name) => { return undefined; },
            (target, name) => { return A; },
            (target, name) => { return B; }
    ];
    let target = {};
    let result = Reflect.decorate(decorators, target, "name", C);
    assert.strictEqual(result, A);
}
export function ReflectDecoratorCorrectTargetInPipelineForFunctionOverload() {
    let sent = [];
    let A = function A() { };
    let B = function B() { };
    let decorators = [
            (target) => { sent.push(target); return undefined; },
            (target) => { sent.push(target); return undefined; },
            (target) => { sent.push(target); return A; },
            (target) => { sent.push(target); return B; }
    ];
    let target = function () { };
    Reflect.decorate(decorators, target);
    assert.deepEqual(sent, [target, B, A, A]);
}
export function ReflectDecoratorCorrectTargetInPipelineForPropertyOverload() {
    let sent = [];
    let decorators = [
            (target, name) => { sent.push(target); },
            (target, name) => { sent.push(target); },
            (target, name) => { sent.push(target); },
            (target, name) => { sent.push(target); }
    ];
    let target = {};
    Reflect.decorate(decorators, target, "name");
    assert.deepEqual(sent, [target, target, target, target]);
}
export function ReflectDecoratorCorrectNameInPipelineForPropertyOverload() {
    let sent = [];
    let decorators = [
            (target, name) => { sent.push(name); },
            (target, name) => { sent.push(name); },
            (target, name) => { sent.push(name); },
            (target, name) => { sent.push(name); }
    ];
    let target = {};
    Reflect.decorate(decorators, target, "name");
    assert.deepEqual(sent, ["name", "name", "name", "name"]);
}
export function ReflectDecoratorCorrectTargetInPipelineForPropertyDescriptorOverload() {
    let sent = [];
    let A = {};
    let B = {};
    let C = {};
    let decorators = [
            (target, name) => { sent.push(target); return undefined; },
            (target, name) => { sent.push(target); return undefined; },
            (target, name) => { sent.push(target); return A; },
            (target, name) => { sent.push(target); return B; }
    ];
    let target = {};
    Reflect.decorate(decorators, target, "name", C);
    assert.deepEqual(sent, [target, target, target, target]);
}
export function ReflectDecoratorCorrectNameInPipelineForPropertyDescriptorOverload() {
    let sent = [];
    let A = {};
    let B = {};
    let C = {};
    let decorators = [
            (target, name) => { sent.push(name); return undefined; },
            (target, name) => { sent.push(name); return undefined; },
            (target, name) => { sent.push(name); return A; },
            (target, name) => { sent.push(name); return B; }
    ];
    let target = {};
    Reflect.decorate(decorators, target, "name", C);
    assert.deepEqual(sent, ["name", "name", "name", "name"]);
}
export function ReflectDecoratorCorrectDescriptorInPipelineForPropertyDescriptorOverload() {
    let sent = [];
    let A = {};
    let B = {};
    let C = {};
    let decorators = [
            (target, name, descriptor) => { sent.push(descriptor); return undefined; },
            (target, name, descriptor) => { sent.push(descriptor); return undefined; },
            (target, name, descriptor) => { sent.push(descriptor); return A; },
            (target, name, descriptor) => { sent.push(descriptor); return B; }
    ];
    let target = {};
    Reflect.decorate(decorators, target, "name", C);
    assert.deepEqual(sent, [C, B, A, A]);
}
//# sourceMappingURL=reflect-decorate.js.map